// -------------------------------------------------------------
// Component : Set Load Uniform On Areas (Excel diff, auto-remove)
// Author    : Generated by OpenAI assistant
// Target    : Rhino 7/8 + Grasshopper, .NET Framework 4.8 (x64)
// Depends   : Grasshopper, ETABSv1 (COM), Microsoft.Office.Interop.Excel
// Panel     : "MGT" / "3.0 Area Object Modelling"
// -------------------------------------------------------------
// Class diagram (simplified)
//   +--------------------------------------------+
//   | GhcSetLoadUniformOnAreas_ExcelInteraction  |
//   +--------------------------------------------+
//   | - _lastRun : bool                          |
//   | - _lastValues : GH_Structure<GH_ObjectWrapper>
//   | - _lastMessages : List<string>             |
//   | - _lastRemoved : List<string>              |
//   +--------------------------------------------+
//   | + SolveInstance(...)                       |
//   |   ├─ ReadExcelSheet(...)                   |
//   |   ├─ PrepareLoadAssignments(...)           |
//   |   ├─ AutoRemoveMissingCombos(...)          |
//   |   └─ TriggerGetComponentRefresh()          |
//   +--------------------------------------------+
//
// Inputs (ordered):
//   0) run         (bool, item)    Rising-edge trigger.
//   1) sapModel    (ETABSv1.cSapModel, item)  ETABS model reference from Attach component.
//   2) excelPath   (string, item)  Full/relative path to workbook containing the sheet.
//   3) sheetName   (string, item)  Worksheet name. Defaults to "Assigned Loads On Areas".
//   4) replaceMode (bool, item)    True = replace, False = add.
//   5) baseline    (generic, tree) OPTIONAL. Values tree from GhcGetLoadUniformOnAreas for diff.
//   6) autoRemove  (bool, item)    True = delete area/pattern combos missing from Excel before reassigning.
//
// Outputs:
//   0) values      (generic, tree) Column-wise branches (5) read from Excel (header row excluded).
//   1) removed     (string, list)  Area/pattern pairs deleted before reassignment.
//   2) messages    (string, list)  Summary + diagnostics.
//
// Behavior Notes:
//   • Reads columns B..F (5 columns) from the specified sheet; row 1 treated as headers.
//   • Converts Excel rows into a column-oriented GH_Structure for downstream inspection.
//   • Assigns uniform surface loads using AreaObj.SetLoadUniform.
//   • Optionally compares the Excel rows with a baseline tree and deletes missing area/pattern combos.
//   • Attempts to unlock the model automatically before removal/assignment.
//   • Direction codes 1..3 default to the Local coordinate system unless overridden in Excel.
//   • Any row with missing/invalid core data is reported as "skipped".
//   • When run is false or not toggled, the component replays the last output messages/tree.
//   • After processing, schedules GhcGetLoadUniformOnAreas components in the document to refresh.
// -------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using ETABSv1;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using static MGT.ComponentShared;
using Excel = Microsoft.Office.Interop.Excel;

namespace MGT
{
    public class GhcSetLoadUniformOnAreas_ExcelInteraction : GH_Component
    {
        private const string DefaultSheetName = "Assigned Loads On Areas";

        private bool _lastRun;
        private GH_Structure<GH_ObjectWrapper> _lastValues = new GH_Structure<GH_ObjectWrapper>();
        private readonly List<string> _lastMessages = new List<string> { "No previous run. Toggle 'run' to assign." };
        private readonly List<string> _lastRemoved = new List<string>();

        public GhcSetLoadUniformOnAreas_ExcelInteraction()
          : base(
                "Set Load Uniform On Areas (Excel Diff)",
                "AreaUDLDiff",
                "Assign uniform surface loads to ETABS area objects by reading an Excel worksheet with optional auto-removal of missing area/pattern combos.\nDeveloped by Mark Bui Quang Anh - Mark.Bui@meinhardtgroup.com",
                "MGT",
                "3.0 Area Object Modelling")
        {
        }

        public override Guid ComponentGuid => new Guid("3B8DE584-49D2-4B97-A38C-D3B46A3D662F");

        protected override Bitmap Icon => null;

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddBooleanParameter("run", "run", "Rising-edge trigger; executes when this turns True.", GH_ParamAccess.item, false);
            p.AddGenericParameter("sapModel", "sapModel", "ETABS cSapModel from the Attach component.", GH_ParamAccess.item);
            p.AddTextParameter("excelPath", "excelPath", "Full or project-relative path to the workbook.", GH_ParamAccess.item, string.Empty);
            p.AddTextParameter("sheetName", "sheetName", "Worksheet name containing the data.", GH_ParamAccess.item, DefaultSheetName);
            p.AddBooleanParameter("replaceMode", "replace", "True = replace existing values, False = add.", GH_ParamAccess.item, true);

            int baselineIndex = p.AddGenericParameter(
                "baseline",
                "baseline",
                "Optional data tree captured from GhcGetLoadUniformOnAreas for diff/removal.",
                GH_ParamAccess.tree);
            p[baselineIndex].Optional = true;

            p.AddBooleanParameter(
                "autoRemove",
                "autoRemove",
                "When True, delete area/pattern combos that disappear from Excel before re-assigning.",
                GH_ParamAccess.item,
                true);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddGenericParameter("values", "values", "Column-wise data tree (5 branches) read from Excel (header row excluded).", GH_ParamAccess.tree);
            p.AddTextParameter("removed", "removed", "Area/pattern pairs deleted prior to reassignment.", GH_ParamAccess.list);
            p.AddTextParameter("messages", "messages", "Summary and diagnostic messages.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess da)
        {
            bool run = false;
            cSapModel sapModel = null;
            string excelPath = null;
            string sheetName = DefaultSheetName;
            bool replaceMode = true;
            bool autoRemove = true;

            GH_Structure<IGH_Goo> baselineTree;

            da.GetData(0, ref run);
            da.GetData(1, ref sapModel);
            da.GetData(2, ref excelPath);
            da.GetData(3, ref sheetName);
            da.GetData(4, ref replaceMode);
            da.GetDataTree(5, out baselineTree);
            da.GetData(6, ref autoRemove);

            bool rising = !_lastRun && run;
            if (!rising)
            {
                da.SetDataTree(0, _lastValues.Duplicate());
                da.SetDataList(1, _lastRemoved.ToArray());
                da.SetDataList(2, _lastMessages.ToArray());
                _lastRun = run;
                return;
            }

            List<string> messages = new List<string>();
            GH_Structure<GH_ObjectWrapper> valueTree = new GH_Structure<GH_ObjectWrapper>();
            List<string> removedSummaries = new List<string>();
            int scheduledRefreshCount = 0;

            try
            {
                if (sapModel == null)
                {
                    throw new InvalidOperationException("sapModel is null. Wire it from the Attach component.");
                }

                string fullPath = ExcelHelpers.ProjectRelative(excelPath);
                if (string.IsNullOrWhiteSpace(fullPath))
                {
                    throw new InvalidOperationException("excelPath is empty.");
                }

                if (!File.Exists(fullPath))
                {
                    throw new FileNotFoundException("Excel workbook not found.", fullPath);
                }

                if (string.IsNullOrWhiteSpace(sheetName))
                {
                    sheetName = DefaultSheetName;
                }

                UiHelpers.ShowDualProgressBar(
                    "Assign Area Uniform Loads",
                    "Reading Excel...",
                    0,
                    string.Empty,
                    0);

                ExcelLoadData excelData = ReadExcelSheet(
                    fullPath,
                    sheetName,
                    (current, maximum, status) => UiHelpers.UpdateExcelProgressBar(current, maximum, status));

                EnsureModelUnlocked(sapModel);

                HashSet<string> existingNames = TryGetExistingAreaNames(sapModel);
                if (existingNames == null)
                {
                    throw new InvalidOperationException("Failed to query area object names from ETABS.");
                }

                HashSet<AreaPatternKey> baselineCombos = autoRemove ? CollectCombosFromValueTree(baselineTree) : null;
                HashSet<AreaPatternKey> desiredCombos = autoRemove ? CollectCombosFromExcel(excelData) : null;

                if (autoRemove && baselineCombos != null && baselineCombos.Count > 0)
                {
                    int removedCount = AutoRemoveMissingCombos(
                        sapModel,
                        baselineCombos,
                        desiredCombos,
                        existingNames,
                        removedSummaries);

                    if (removedCount > 0)
                    {
                        messages.Add($"Auto-removed {removedCount} area/pattern {(removedCount == 1 ? "combo" : "combos")} missing from Excel.");
                    }
                    else if (removedSummaries.Count > 0)
                    {
                        messages.Add("Attempted to auto-remove area/pattern combos, but ETABS reported failures.");
                    }
                }

                valueTree = BuildValueTree(excelData);

                if (excelData.RowCount == 0)
                {
                    messages.Add($"Read 0 data rows from sheet '{sheetName}'. Nothing to assign.");
                    UiHelpers.CloseProgressBar();
                    scheduledRefreshCount = TriggerGetComponentRefresh();
                }
                else
                {
                    messages.Add($"Read {excelData.RowCount} data rows from sheet '{sheetName}'.");

                    List<string> skippedRows = new List<string>();
                    List<string> missingRows = new List<string>();
                    List<string> errorRows = new List<string>();

                    List<PreparedLoadAssignment> preparedLoads = PrepareLoadAssignments(
                        excelData,
                        existingNames,
                        skippedRows,
                        missingRows);

                    int totalPrepared = preparedLoads.Count;
                    int assignedCount = 0;
                    int failedCount = 0;

                    UiHelpers.UpdateAssignmentProgressBar(0, totalPrepared, BuildProgressStatus(0, totalPrepared));

                    try
                    {
                        for (int i = 0; i < preparedLoads.Count; i++)
                        {
                            PreparedLoadAssignment prepared = preparedLoads[i];

                            int ret = sapModel.AreaObj.SetLoadUniform(
                                prepared.AreaName,
                                prepared.LoadPattern,
                                prepared.Value,
                                prepared.Direction,
                                replaceMode,
                                prepared.CoordinateSystem,
                                eItemType.Objects);

                            if (ret == 0)
                            {
                                assignedCount++;
                            }
                            else
                            {
                                failedCount++;
                                errorRows.Add($"{prepared.RowIndex}:{prepared.AreaName}");
                            }

                            UiHelpers.UpdateAssignmentProgressBar(
                                assignedCount,
                                totalPrepared,
                                BuildProgressStatus(assignedCount, totalPrepared));
                        }
                    }
                    finally
                    {
                        UiHelpers.CloseProgressBar();
                    }

                    messages.Add($"{Plural(assignedCount, "area")} successfully assigned, {Plural(failedCount, "area")} unsuccessful.");

                    if (skippedRows.Count > 0)
                    {
                        messages.Add("Skipped rows (0-based index:area): " + string.Join(", ", skippedRows));
                    }

                    if (missingRows.Count > 0)
                    {
                        messages.Add("Areas not found (rowIndex:area): " + string.Join(", ", missingRows));
                    }

                    if (errorRows.Count > 0)
                    {
                        messages.Add("ETABS errors (rowIndex:area): " + string.Join(", ", errorRows));
                    }

                    TryRefreshView(sapModel);
                    scheduledRefreshCount = TriggerGetComponentRefresh();
                }
            }
            catch (Exception ex)
            {
                messages.Add("Error: " + ex.Message);
            }

            UiHelpers.CloseProgressBar();

            if (scheduledRefreshCount > 0)
            {
                messages.Add($"Scheduled refresh for {Plural(scheduledRefreshCount, "Get Area Uniform Loads component")}.");
            }

            da.SetDataTree(0, valueTree);
            da.SetDataList(1, removedSummaries);
            da.SetDataList(2, messages.ToArray());

            _lastValues = valueTree.Duplicate();
            _lastRemoved.Clear();
            _lastRemoved.AddRange(removedSummaries);
            _lastMessages.Clear();
            _lastMessages.AddRange(messages);
            _lastRun = run;
        }

        private static List<PreparedLoadAssignment> PrepareLoadAssignments(
            ExcelLoadData excelData,
            HashSet<string> existingNames,
            List<string> skippedRows,
            List<string> missingRows)
        {
            List<PreparedLoadAssignment> prepared = new List<PreparedLoadAssignment>();
            if (excelData == null)
            {
                return prepared;
            }

            for (int i = 0; i < excelData.RowCount; i++)
            {
                string areaName = TrimOrEmpty(excelData.AreaName[i]);
                string loadPattern = TrimOrEmpty(excelData.LoadPattern[i]);
                string coordinateSystem = TrimOrEmpty(excelData.CoordinateSystem[i]);
                int? rawDirection = excelData.Direction[i];
                double? rawValue = excelData.Value[i];

                if (string.IsNullOrEmpty(areaName) || string.IsNullOrEmpty(loadPattern) || !rawDirection.HasValue || !rawValue.HasValue)
                {
                    skippedRows.Add($"{i}:{areaName}");
                    continue;
                }

                double value = rawValue.Value;
                if (IsInvalidNumber(value))
                {
                    skippedRows.Add($"{i}:{areaName}");
                    continue;
                }

                int direction = ClampDirCode(rawDirection.Value);
                string resolvedCoordinate = ResolveDirectionReferenceArea(direction);

                excelData.AreaName[i] = areaName;
                excelData.LoadPattern[i] = loadPattern;
                excelData.CoordinateSystem[i] = resolvedCoordinate;
                excelData.Direction[i] = direction;
                excelData.Value[i] = value;

                if (existingNames != null && !existingNames.Contains(areaName))
                {
                    missingRows.Add($"{i}:{areaName}");
                    continue;
                }

                prepared.Add(new PreparedLoadAssignment(
                    i,
                    areaName,
                    loadPattern,
                    direction,
                    value,
                    resolvedCoordinate));
            }

            return prepared;
        }

        private static string BuildProgressStatus(int assignedCount, int totalPrepared)
        {
            if (totalPrepared <= 0)
            {
                return string.Empty;
            }

            double percent = totalPrepared == 0 ? 0.0 : (assignedCount / (double)totalPrepared) * 100.0;
            return $"Assigned {assignedCount} of {totalPrepared} areas ({percent:0.##}%).";
        }

        private static string BuildExcelProgressStatus(int processedRows, int totalRows)
        {
            int safeProcessed = Math.Max(0, processedRows);
            int safeTotal = Math.Max(0, totalRows);
            if (safeTotal <= 0)
            {
                return $"Reading Excel ({safeProcessed})";
            }

            int clamped = Math.Min(safeProcessed, safeTotal);
            double percent = (clamped / (double)safeTotal) * 100.0;
            return $"Reading Excel {clamped} of {safeTotal} rows ({percent:0.##}%).";
        }

        private static string BuildExcelDoneStatus(int rowCount)
        {
            int safeCount = Math.Max(0, rowCount);
            return safeCount == 1
                ? "Excel Done (1 row)"
                : $"Excel Done ({safeCount} rows)";
        }

        private static GH_Structure<GH_ObjectWrapper> BuildValueTree(ExcelLoadData data)
        {
            GH_Structure<GH_ObjectWrapper> tree = new GH_Structure<GH_ObjectWrapper>();

            AppendBranch(tree, 0, data?.AreaName);
            AppendBranch(tree, 1, data?.LoadPattern);
            AppendBranch(tree, 2, data?.CoordinateSystem);
            AppendBranch(tree, 3, data?.Direction);
            AppendBranch(tree, 4, data?.Value);

            return tree;
        }

        private static void AppendBranch<T>(GH_Structure<GH_ObjectWrapper> tree, int index, IList<T> values)
        {
            GH_Path path = new GH_Path(index);
            tree.EnsurePath(path);

            if (values == null)
            {
                return;
            }

            for (int i = 0; i < values.Count; i++)
            {
                tree.Append(new GH_ObjectWrapper(values[i]), path);
            }
        }

        private static ExcelLoadData ReadExcelSheet(
            string fullPath,
            string sheetName,
            Action<int, int, string> progressCallback = null)
        {
            Excel.Application app = null;
            Excel.Workbooks books = null;
            Excel.Workbook wb = null;
            Excel.Worksheet ws = null;
            Excel.Range usedRange = null;

            try
            {
                app = new Excel.Application
                {
                    Visible = false,
                    DisplayAlerts = false,
                    UserControl = false
                };

                books = app.Workbooks;
                wb = books.Open(
                    Filename: fullPath,
                    UpdateLinks: 0,
                    ReadOnly: true,
                    IgnoreReadOnlyRecommended: true,
                    AddToMru: false);

                if (!string.Equals(sheetName, DefaultSheetName, StringComparison.OrdinalIgnoreCase))
                {
                    throw new InvalidOperationException($"Invalid workbook: expected sheet name '{DefaultSheetName}'.");
                }

                ws = FindWorksheet(wb, sheetName);
                if (ws == null)
                {
                    throw new InvalidOperationException($"Worksheet '{sheetName}' not found in '{Path.GetFileName(fullPath)}'.");
                }

                ExcelLoadData data = new ExcelLoadData();

                const int startColumn = 2; // Column B
                const int columnCount = 5;

                string[] expectedHeaders =
                {
                    "AreaName",
                    "LoadPattern",
                    "CoordinateSystem",
                    "Direction",
                    "Value"
                };

                for (int col = 0; col < columnCount; col++)
                {
                    Excel.Range headerCell = null;
                    try
                    {
                        headerCell = (Excel.Range)ws.Cells[1, startColumn + col];
                        string headerValue = TrimOrEmpty(headerCell?.Value2);
                        data.Headers.Add(headerValue);

                        if (!string.Equals(headerValue, expectedHeaders[col], StringComparison.OrdinalIgnoreCase))
                        {
                            char columnLetter = (char)('A' + startColumn + col - 1);
                            throw new InvalidOperationException(
                                $"Invalid workbook: expected header '{expectedHeaders[col]}' in column {columnLetter}, found '{headerValue}'.");
                        }
                    }
                    finally
                    {
                        ExcelHelpers.ReleaseCom(headerCell);
                    }
                }

                usedRange = ws.UsedRange;
                int lastRow = 1;
                if (usedRange != null)
                {
                    try
                    {
                        lastRow = Math.Max(lastRow, usedRange.Row + usedRange.Rows.Count - 1);
                    }
                    catch
                    {
                        lastRow = 1;
                    }
                }

                int totalRows = Math.Max(0, lastRow - 1);
                progressCallback?.Invoke(0, totalRows, BuildExcelProgressStatus(0, totalRows));

                int processedRows = 0;

                for (int row = 2; row <= lastRow; row++)
                {
                    object[] rowValues = new object[columnCount];
                    bool hasData = false;

                    for (int col = 0; col < columnCount; col++)
                    {
                        Excel.Range cell = null;
                        try
                        {
                            cell = (Excel.Range)ws.Cells[row, startColumn + col];
                            object value = cell?.Value2;
                            rowValues[col] = value;
                            if (!IsNullOrEmptyExcel(value))
                            {
                                hasData = true;
                            }
                        }
                        finally
                        {
                            ExcelHelpers.ReleaseCom(cell);
                        }
                    }

                    processedRows++;
                    int current = totalRows > 0 ? Math.Min(processedRows, totalRows) : processedRows;
                    progressCallback?.Invoke(current, totalRows, BuildExcelProgressStatus(current, totalRows));

                    if (!hasData)
                    {
                        continue;
                    }

                    data.AreaName.Add(TrimOrEmpty(rowValues[0]));
                    data.LoadPattern.Add(TrimOrEmpty(rowValues[1]));
                    data.CoordinateSystem.Add(TrimOrEmpty(rowValues[2]));
                    data.Direction.Add(ParseNullableInt(rowValues[3]));
                    data.Value.Add(ParseNullableDouble(rowValues[4]));
                }

                progressCallback?.Invoke(data.RowCount, data.RowCount, BuildExcelDoneStatus(data.RowCount));

                return data;
            }
            finally
            {
                ExcelHelpers.ReleaseCom(usedRange);

                if (wb != null)
                {
                    try { wb.Close(false); } catch { }
                }

                ExcelHelpers.ReleaseCom(ws);
                ExcelHelpers.ReleaseCom(wb);
                ExcelHelpers.ReleaseCom(books);

                if (app != null)
                {
                    try { app.Quit(); } catch { }
                }

                ExcelHelpers.ReleaseCom(app);
            }
        }

        private static Excel.Worksheet FindWorksheet(Excel.Workbook wb, string sheetName)
        {
            if (wb == null)
            {
                return null;
            }

            if (string.IsNullOrWhiteSpace(sheetName))
            {
                sheetName = "Sheet1";
            }

            Excel.Worksheet result = null;

            for (int i = 1; i <= wb.Worksheets.Count; i++)
            {
                Excel.Worksheet candidate = null;
                try
                {
                    candidate = (Excel.Worksheet)wb.Worksheets[i];
                    if (candidate != null && string.Equals(candidate.Name, sheetName, StringComparison.OrdinalIgnoreCase))
                    {
                        result = candidate;
                        candidate = null;
                        break;
                    }
                }
                finally
                {
                    ExcelHelpers.ReleaseCom(candidate);
                }
            }

            return result;
        }

        private static bool IsNullOrEmptyExcel(object value)
        {
            if (value == null)
            {
                return true;
            }

            if (value is string s)
            {
                return string.IsNullOrWhiteSpace(s);
            }

            if (value is double d)
            {
                return double.IsNaN(d) || double.IsInfinity(d);
            }

            return false;
        }

        private static string TrimOrEmpty(object value)
        {
            string raw = Convert.ToString(value, CultureInfo.InvariantCulture);
            return string.IsNullOrWhiteSpace(raw) ? string.Empty : raw.Trim();
        }

        private static int? ParseNullableInt(object value)
        {
            if (value == null)
            {
                return null;
            }

            if (value is double d)
            {
                return (int)Math.Round(d, MidpointRounding.AwayFromZero);
            }

            string s = TrimOrEmpty(value);
            if (string.IsNullOrEmpty(s))
            {
                return null;
            }

            if (int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out int result))
            {
                return result;
            }

            return null;
        }

        private static double? ParseNullableDouble(object value)
        {
            if (value == null)
            {
                return null;
            }

            if (value is double d)
            {
                return d;
            }

            string s = TrimOrEmpty(value);
            if (string.IsNullOrEmpty(s))
            {
                return null;
            }

            if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out double result))
            {
                return result;
            }

            return null;
        }

        private readonly struct PreparedLoadAssignment
        {
            internal PreparedLoadAssignment(
                int rowIndex,
                string areaName,
                string loadPattern,
                int direction,
                double value,
                string coordinateSystem)
            {
                RowIndex = rowIndex;
                AreaName = areaName;
                LoadPattern = loadPattern;
                Direction = direction;
                Value = value;
                CoordinateSystem = coordinateSystem;
            }

            internal int RowIndex { get; }
            internal string AreaName { get; }
            internal string LoadPattern { get; }
            internal int Direction { get; }
            internal double Value { get; }
            internal string CoordinateSystem { get; }
        }

        private readonly struct AreaPatternKey : IEquatable<AreaPatternKey>
        {
            internal AreaPatternKey(string areaName, string loadPattern)
            {
                AreaName = string.IsNullOrWhiteSpace(areaName) ? string.Empty : areaName.Trim();
                LoadPattern = string.IsNullOrWhiteSpace(loadPattern) ? string.Empty : loadPattern.Trim();
            }

            internal string AreaName { get; }
            internal string LoadPattern { get; }

            public bool Equals(AreaPatternKey other)
            {
                return string.Equals(AreaName, other.AreaName, StringComparison.OrdinalIgnoreCase) &&
                       string.Equals(LoadPattern, other.LoadPattern, StringComparison.OrdinalIgnoreCase);
            }

            public override bool Equals(object obj)
            {
                return obj is AreaPatternKey other && Equals(other);
            }

            public override int GetHashCode()
            {
                int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(AreaName ?? string.Empty);
                hash = (hash * 397) ^ StringComparer.OrdinalIgnoreCase.GetHashCode(LoadPattern ?? string.Empty);
                return hash;
            }
        }

        private static int AutoRemoveMissingCombos(
            cSapModel sapModel,
            HashSet<AreaPatternKey> baselineCombos,
            HashSet<AreaPatternKey> desiredCombos,
            HashSet<string> existingNames,
            IList<string> removalSummaries)
        {
            if (sapModel == null || baselineCombos == null || baselineCombos.Count == 0)
            {
                return 0;
            }

            HashSet<AreaPatternKey> desired = desiredCombos ?? new HashSet<AreaPatternKey>();
            HashSet<AreaPatternKey> attempted = new HashSet<AreaPatternKey>();
            int removedCount = 0;

            foreach (AreaPatternKey combo in baselineCombos)
            {
                if (!attempted.Add(combo))
                {
                    continue;
                }

                if (desired.Contains(combo))
                {
                    continue;
                }

                if (existingNames != null && !existingNames.Contains(combo.AreaName))
                {
                    continue;
                }

                bool removed = TryDeleteUniformCombo(sapModel, combo.AreaName, combo.LoadPattern);
                if (removalSummaries != null)
                {
                    removalSummaries.Add(removed
                        ? $"Removed {combo.AreaName} / {combo.LoadPattern}"
                        : $"Failed to remove {combo.AreaName} / {combo.LoadPattern}");
                }

                if (removed)
                {
                    removedCount++;
                }
            }

            return removedCount;
        }

        private static HashSet<AreaPatternKey> CollectCombosFromExcel(ExcelLoadData data)
        {
            HashSet<AreaPatternKey> combos = new HashSet<AreaPatternKey>();
            if (data == null)
            {
                return combos;
            }

            for (int i = 0; i < data.RowCount; i++)
            {
                string area = TrimOrEmpty(data.AreaName[i]);
                string pattern = TrimOrEmpty(data.LoadPattern[i]);

                if (string.IsNullOrEmpty(area) || string.IsNullOrEmpty(pattern))
                {
                    continue;
                }

                combos.Add(new AreaPatternKey(area, pattern));
            }

            return combos;
        }

        private static HashSet<AreaPatternKey> CollectCombosFromValueTree(GH_Structure<IGH_Goo> tree)
        {
            HashSet<AreaPatternKey> combos = new HashSet<AreaPatternKey>();
            if (tree == null)
            {
                return combos;
            }

            GH_Path areaPath = new GH_Path(0);
            GH_Path patternPath = new GH_Path(1);

            IList areaBranch = tree.get_Branch(areaPath);
            IList patternBranch = tree.get_Branch(patternPath);

            if (areaBranch == null || patternBranch == null)
            {
                return combos;
            }

            int rowCount = Math.Max(areaBranch.Count, patternBranch.Count);
            for (int i = 0; i < rowCount; i++)
            {
                string area = GooToTrimmedString(areaBranch, i);
                string pattern = GooToTrimmedString(patternBranch, i);

                if (string.IsNullOrEmpty(area) || string.IsNullOrEmpty(pattern))
                {
                    continue;
                }

                combos.Add(new AreaPatternKey(area, pattern));
            }

            return combos;
        }

        private static string GooToTrimmedString(IList branch, int index)
        {
            if (branch == null || index < 0 || index >= branch.Count)
            {
                return string.Empty;
            }

            if (!(branch[index] is IGH_Goo goo))
            {
                return string.Empty;
            }

            if (goo is GH_String ghString)
            {
                string candidate = ghString.Value;
                return string.IsNullOrWhiteSpace(candidate) ? string.Empty : candidate.Trim();
            }

            if (goo is GH_ObjectWrapper wrapper)
            {
                object wrapped = wrapper.Value;
                if (wrapped is GH_String wrappedString)
                {
                    string candidate = wrappedString.Value;
                    return string.IsNullOrWhiteSpace(candidate) ? string.Empty : candidate.Trim();
                }

                string wrappedText = Convert.ToString(wrapped, CultureInfo.InvariantCulture);
                return string.IsNullOrWhiteSpace(wrappedText) ? string.Empty : wrappedText.Trim();
            }

            if (GH_Convert.ToString(goo, out string converted, GH_Conversion.Both))
            {
                return string.IsNullOrWhiteSpace(converted) ? string.Empty : converted.Trim();
            }

            object scriptValue = goo.ScriptVariable();
            string result = Convert.ToString(scriptValue, CultureInfo.InvariantCulture);
            return string.IsNullOrWhiteSpace(result) ? string.Empty : result.Trim();
        }

        private static bool TryDeleteUniformCombo(cSapModel model, string areaName, string loadPattern)
        {
            if (model == null)
            {
                return false;
            }

            try
            {
                int ret = model.AreaObj.DeleteLoadUniform(
                    areaName ?? string.Empty,
                    loadPattern ?? string.Empty,
                    eItemType.Objects);

                return ret == 0;
            }
            catch
            {
                return false;
            }
        }

        private int TriggerGetComponentRefresh()
        {
            try
            {
                GH_Document document = OnPingDocument();
                if (document == null)
                {
                    return 0;
                }

                List<GhcGetLoadUniformOnAreas> targets = new List<GhcGetLoadUniformOnAreas>();
                foreach (IGH_DocumentObject obj in document.Objects)
                {
                    if (obj is GhcGetLoadUniformOnAreas getComponent &&
                        ReferenceEquals(getComponent.OnPingDocument(), document) &&
                        !getComponent.Locked &&
                        !getComponent.Hidden)
                    {
                        targets.Add(getComponent);
                    }
                }

                if (targets.Count == 0)
                {
                    return 0;
                }

                document.ScheduleSolution(5, _ =>
                {
                    foreach (GhcGetLoadUniformOnAreas target in targets)
                    {
                        if (!target.Locked && !target.Hidden)
                        {
                            target.ExpireSolution(false);
                        }
                    }
                });

                return targets.Count;
            }
            catch
            {
                return 0;
            }
        }
    }
}

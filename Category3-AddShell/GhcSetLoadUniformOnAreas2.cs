// -------------------------------------------------------------
// Component : Set Load Uniform On Areas (Excel-driven)
// Author    : Generated by OpenAI assistant
// Target    : Rhino 7/8 + Grasshopper, .NET Framework 4.8 (x64)
// Depends   : Grasshopper, ETABSv1 (COM), Microsoft.Office.Interop.Excel
// Panel     : "ETABS API" / "3.0 Area Object Modelling"
// -------------------------------------------------------------
// Inputs (ordered):
//   0) run         (bool, item)    Rising-edge trigger.
//   1) sapModel    (ETABSv1.cSapModel, item)  ETABS model reference from Attach component.
//   2) excelPath   (string, item)  Full/relative path to workbook containing the sheet.
//   3) sheetName   (string, item)  Worksheet name. Defaults to "Assigned Loads On Areas".
//   4) replaceMode (bool, item)    True = replace, False = add.
//
// Outputs:
//   0) values      (generic, tree) Column-wise branches (5) read from Excel (header row excluded).
//   1) messages    (string, list)  Summary + diagnostics.
//
// Behavior Notes:
//   • Reads columns B..F (5 columns) from the specified sheet; row 1 treated as headers.
//   • Converts Excel rows into a column-oriented GH_Structure for downstream inspection.
//   • Assigns uniform surface loads using AreaObj.SetLoadUniform.
//   • Attempts to unlock the model automatically before assignment.
//   • Direction codes 1..3 default to the Local coordinate system unless overridden in Excel.
//   • Any row with missing/invalid core data is reported as "skipped".
//   • When run is false or not toggled, the component replays the last output messages/tree.
// -------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using ETABSv1;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using static GhcETABSAPI.ComponentShared;

namespace GhcETABSAPI
{
    public class GhcSetLoadUniformOnAreas2 : GH_Component
    {
        private const string DefaultSheetName = "Assigned Loads On Areas";

        private bool _lastRun;
        private GH_Structure<GH_ObjectWrapper> _lastValues = new GH_Structure<GH_ObjectWrapper>();
        private readonly List<string> _lastMessages = new List<string> { "No previous run. Toggle 'run' to assign." };

        public GhcSetLoadUniformOnAreas2()
          : base(
                "Set Load Uniform On Areas (Excel)",
                "AreaUDLXl",
                "Assign uniform surface loads to ETABS area objects by reading an Excel worksheet.",
                "ETABS API",
                "3.0 Area Object Modelling")
        {
        }

        public override Guid ComponentGuid => new Guid("e5a3d1a3-9970-4474-90ab-9c4d57a13618");

        protected override Bitmap Icon => null;

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddBooleanParameter("run", "run", "Rising-edge trigger; executes when this turns True.", GH_ParamAccess.item, false);
            p.AddGenericParameter("sapModel", "sapModel", "ETABS cSapModel from the Attach component.", GH_ParamAccess.item);
            p.AddTextParameter("excelPath", "excelPath", "Full or project-relative path to the workbook.", GH_ParamAccess.item, string.Empty);
            p.AddTextParameter("sheetName", "sheetName", "Worksheet name containing the data.", GH_ParamAccess.item, DefaultSheetName);
            p.AddBooleanParameter("replaceMode", "replace", "True = replace existing values, False = add.", GH_ParamAccess.item, true);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddGenericParameter("values", "values", "Column-wise data tree (5 branches) read from Excel (header row excluded).", GH_ParamAccess.tree);
            p.AddTextParameter("messages", "messages", "Summary and diagnostic messages.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess da)
        {
            bool run = false;
            cSapModel sapModel = null;
            string excelPath = null;
            string sheetName = DefaultSheetName;
            bool replaceMode = true;

            da.GetData(0, ref run);
            da.GetData(1, ref sapModel);
            da.GetData(2, ref excelPath);
            da.GetData(3, ref sheetName);
            da.GetData(4, ref replaceMode);

            bool rising = !_lastRun && run;
            if (!rising)
            {
                da.SetDataTree(0, _lastValues.Duplicate());
                da.SetDataList(1, _lastMessages.ToArray());
                _lastRun = run;
                return;
            }

            List<string> messages = new List<string>();
            GH_Structure<GH_ObjectWrapper> valueTree = new GH_Structure<GH_ObjectWrapper>();

            try
            {
                if (sapModel == null)
                {
                    throw new InvalidOperationException("sapModel is null. Wire it from the Attach component.");
                }

                string fullPath = ExcelHelpers.ProjectRelative(excelPath);
                if (string.IsNullOrWhiteSpace(fullPath))
                {
                    throw new InvalidOperationException("excelPath is empty.");
                }

                if (!File.Exists(fullPath))
                {
                    throw new FileNotFoundException("Excel workbook not found.", fullPath);
                }

                if (string.IsNullOrWhiteSpace(sheetName))
                {
                    sheetName = DefaultSheetName;
                }

                UiHelpers.ShowDualProgressBar(
                    "Assign Area Uniform Loads",
                    "Reading Excel...",
                    0,
                    string.Empty,
                    0);

                AreaExcelData excelData = AreaExcelData.Read(
                    fullPath,
                    sheetName,
                    (current, maximum, status) => UiHelpers.UpdateExcelProgressBar(current, maximum, status));

                if (excelData.RowCount == 0)
                {
                    valueTree = BuildValueTree(excelData);
                    messages.Add($"Read 0 data rows from sheet '{sheetName}'. Nothing to assign.");
                }
                else
                {
                    messages.Add($"Read {excelData.RowCount} data rows from sheet '{sheetName}'.");

                    EnsureModelUnlocked(sapModel);

                    HashSet<string> existingNames = TryGetExistingAreaNames(sapModel);
                    if (existingNames == null)
                    {
                        throw new InvalidOperationException("Failed to query area object names from ETABS.");
                    }

                    List<string> skippedRows = new List<string>();
                    List<string> missingRows = new List<string>();
                    List<string> errorRows = new List<string>();

                    List<PreparedLoadAssignment> preparedLoads = PrepareLoadAssignments(
                        excelData,
                        existingNames,
                        skippedRows,
                        missingRows);

                    valueTree = BuildValueTree(excelData);

                    int totalPrepared = preparedLoads.Count;
                    int assignedCount = 0;
                    int failedCount = 0;

                    UiHelpers.UpdateAssignmentProgressBar(0, totalPrepared, BuildProgressStatus(0, totalPrepared));

                    try
                    {
                        for (int i = 0; i < preparedLoads.Count; i++)
                        {
                            PreparedLoadAssignment prepared = preparedLoads[i];

                            int ret = sapModel.AreaObj.SetLoadUniform(
                                prepared.AreaName,
                                prepared.LoadPattern,
                                prepared.Value,
                                prepared.Direction,
                                replaceMode,
                                prepared.CoordinateSystem,
                                eItemType.Objects);

                            if (ret == 0)
                            {
                                assignedCount++;
                            }
                            else
                            {
                                failedCount++;
                                errorRows.Add($"{prepared.RowIndex}:{prepared.AreaName}");
                            }

                            UiHelpers.UpdateAssignmentProgressBar(
                                assignedCount,
                                totalPrepared,
                                BuildProgressStatus(assignedCount, totalPrepared));
                        }
                    }
                    finally
                    {
                        UiHelpers.CloseProgressBar();
                    }

                    messages.Add($"{Plural(assignedCount, "area")} successfully assigned, {Plural(failedCount, "area")} unsuccessful.");

                    if (skippedRows.Count > 0)
                    {
                        messages.Add("Skipped rows (0-based index:area): " + string.Join(", ", skippedRows));
                    }

                    if (missingRows.Count > 0)
                    {
                        messages.Add("Areas not found (rowIndex:area): " + string.Join(", ", missingRows));
                    }

                    if (errorRows.Count > 0)
                    {
                        messages.Add("ETABS errors (rowIndex:area): " + string.Join(", ", errorRows));
                    }

                    TryRefreshView(sapModel);
                }
            }
            catch (Exception ex)
            {
                messages.Add("Error: " + ex.Message);
            }

            UiHelpers.CloseProgressBar();

            da.SetDataTree(0, valueTree);
            da.SetDataList(1, messages.ToArray());

            _lastValues = valueTree.Duplicate();
            _lastMessages.Clear();
            _lastMessages.AddRange(messages);
            _lastRun = run;
        }

        private static List<PreparedLoadAssignment> PrepareLoadAssignments(
            AreaExcelData excelData,
            HashSet<string> existingNames,
            List<string> skippedRows,
            List<string> missingRows)
        {
            List<PreparedLoadAssignment> prepared = new List<PreparedLoadAssignment>();
            if (excelData == null)
            {
                return prepared;
            }

            for (int i = 0; i < excelData.RowCount; i++)
            {
                string areaName = ExcelHelpers.TrimOrEmpty(excelData.AreaName[i]);
                string loadPattern = ExcelHelpers.TrimOrEmpty(excelData.LoadPattern[i]);
                string coordinateSystem = ExcelHelpers.TrimOrEmpty(excelData.CoordinateSystem[i]);
                int? rawDirection = excelData.Direction[i];
                double? rawValue = excelData.Value[i];

                if (string.IsNullOrEmpty(areaName) || string.IsNullOrEmpty(loadPattern) || !rawDirection.HasValue || !rawValue.HasValue)
                {
                    skippedRows.Add($"{i}:{areaName}");
                    continue;
                }

                double value = rawValue.Value;
                if (IsInvalidNumber(value))
                {
                    skippedRows.Add($"{i}:{areaName}");
                    continue;
                }

                int direction = ClampDirCode(rawDirection.Value);
                string resolvedCoordinate = ResolveDirectionReferenceArea(direction);


                excelData.AreaName[i] = areaName;
                excelData.LoadPattern[i] = loadPattern;
                excelData.CoordinateSystem[i] = resolvedCoordinate;
                excelData.Direction[i] = direction;
                excelData.Value[i] = value;

                if (existingNames != null && !existingNames.Contains(areaName))
                {
                    missingRows.Add($"{i}:{areaName}");
                    continue;
                }

                prepared.Add(new PreparedLoadAssignment(
                    i,
                    areaName,
                    loadPattern,
                    direction,
                    value,
                    resolvedCoordinate));
            }

            return prepared;
        }

        private static GH_Structure<GH_ObjectWrapper> BuildValueTree(AreaExcelData data)
        {
            GH_Structure<GH_ObjectWrapper> tree = new GH_Structure<GH_ObjectWrapper>();

            AppendBranch(tree, 0, data.AreaName);
            AppendBranch(tree, 1, data.LoadPattern);
            AppendBranch(tree, 2, data.CoordinateSystem);
            AppendBranch(tree, 3, data.Direction);
            AppendBranch(tree, 4, data.Value);

            return tree;
        }

        private static void AppendBranch<T>(GH_Structure<GH_ObjectWrapper> tree, int index, IList<T> values)
        {
            GH_Path path = new GH_Path(index);
            tree.EnsurePath(path);

            if (values == null)
            {
                return;
            }

            for (int i = 0; i < values.Count; i++)
            {
                tree.Append(new GH_ObjectWrapper(values[i]), path);
            }
        }

        private static string BuildProgressStatus(int assignedCount, int totalPrepared)
        {
            if (totalPrepared <= 0)
            {
                return string.Empty;
            }

            double percent = totalPrepared == 0 ? 0.0 : (assignedCount / (double)totalPrepared) * 100.0;
            return $"Assigned {assignedCount} of {totalPrepared} areas ({percent:0.##}%).";
        }

        private readonly struct PreparedLoadAssignment
        {
            internal PreparedLoadAssignment(
                int rowIndex,
                string areaName,
                string loadPattern,
                int direction,
                double value,
                string coordinateSystem)
            {
                RowIndex = rowIndex;
                AreaName = areaName;
                LoadPattern = loadPattern;
                Direction = direction;
                Value = value;
                CoordinateSystem = coordinateSystem;
            }

            internal int RowIndex { get; }
            internal string AreaName { get; }
            internal string LoadPattern { get; }
            internal int Direction { get; }
            internal double Value { get; }
            internal string CoordinateSystem { get; }
        }

        private static void TryRefreshView(cSapModel model)
        {
            if (model == null)
            {
                return;
            }

            try
            {
                model.View.RefreshView(0, false);
            }
            catch
            {
                // ignored
            }
        }
    }

    internal sealed class AreaExcelData
    {
        private AreaExcelData()
        {
        }

        internal static AreaExcelData Read(
            string fullPath,
            string sheetName,
            Action<int, int, string> progressCallback)
        {
            const string expectedSheetName = "Assigned Loads On Areas";
            string targetSheet = string.IsNullOrWhiteSpace(sheetName) ? expectedSheetName : sheetName;
            if (!string.Equals(targetSheet, expectedSheetName, StringComparison.OrdinalIgnoreCase))
            {
                throw new InvalidOperationException($"Invalid workbook: expected sheet name '{expectedSheetName}'.");
            }

            string[] expectedHeaders =
            {
                "AreaName",
                "LoadPattern",
                "CoordinateSystem",
                "Direction",
                "Value"
            };

            ExcelSheetColumnarData table = ExcelHelpers.ReadColumnTable(
                fullPath,
                targetSheet,
                2,
                expectedHeaders,
                progressCallback);

            AreaExcelData data = new AreaExcelData();
            data.Headers.AddRange(table.Headers);

            int rowCount = table.RowCount;
            List<object> areaNames = table.GetColumn(0);
            List<object> loadPatterns = table.GetColumn(1);
            List<object> coordinateSystems = table.GetColumn(2);
            List<object> directions = table.GetColumn(3);
            List<object> values = table.GetColumn(4);

            for (int i = 0; i < rowCount; i++)
            {
                data.AreaName.Add(ExcelHelpers.TrimOrEmpty(areaNames[i]));
                data.LoadPattern.Add(ExcelHelpers.TrimOrEmpty(loadPatterns[i]));
                data.CoordinateSystem.Add(ExcelHelpers.TrimOrEmpty(coordinateSystems[i]));
                data.Direction.Add(ParseNullableInt(directions[i]));
                data.Value.Add(ParseNullableDouble(values[i]));
            }

            return data;
        }

        internal List<string> Headers { get; } = new List<string>();
        internal List<string> AreaName { get; } = new List<string>();
        internal List<string> LoadPattern { get; } = new List<string>();
        internal List<string> CoordinateSystem { get; } = new List<string>();
        internal List<int?> Direction { get; } = new List<int?>();
        internal List<double?> Value { get; } = new List<double?>();

        internal int RowCount => AreaName.Count;

        private static int? ParseNullableInt(object value)
        {
            if (value == null)
            {
                return 0;
            }

            if (value is double d)
            {
                return (int)Math.Round(d, MidpointRounding.AwayFromZero);
            }

            return ExcelHelpers.ParseNullableInt(value);
        }

        private static double? ParseNullableDouble(object value)
        {
            if (value == null)
            {
                return 0.0;
            }

            if (value is double d)
            {
                return d;
            }

            return ExcelHelpers.ParseNullableDouble(value);
        }
    }
}

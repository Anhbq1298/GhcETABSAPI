// -------------------------------------------------------------
// Component : Set Point Info (Excel diff)
// Author    : Generated by OpenAI assistant
// Target    : Rhino 7/8 + Grasshopper, .NET Framework 8.0 (x64)
// Depends   : Grasshopper, ETABSv1 (COM), Microsoft.Office.Interop.Excel
// Panel     : "MGT" / "2.0 Point Object Modelling"
// -------------------------------------------------------------
// Inputs (ordered):
//   0) run        (bool, item)    Rising-edge trigger.
//   1) sapModel   (ETABSv1.cSapModel, item)  ETABS model reference from Attach component.
//   2) excelPath  (string, item)  Full/relative path to workbook containing the sheet.
//   3) sheetName  (string, item)  Worksheet name. Defaults to "Point Info".
//   4) baseline   (generic, tree) OPTIONAL. Values tree from GhcGetPointInfo for comparison/highlighting.
//
// Outputs:
//   0) values     (generic, tree) Column-wise branches (6) read from Excel (header row excluded).
//   1) actions    (string, list)  Rename/move actions executed on ETABS points.
//   2) messages   (string, list)  Summary + diagnostics.
//
// Behavior Notes:
//   • Reads columns A..F (6 columns) from the specified sheet; row 1 treated as headers.
//   • Highlights cells whose values differ from the supplied baseline tree by filling them grey.
//   • When UniqueName changes, PointObj.ChangeName is used to rename the point in ETABS.
//   • When X/Y/Z differ from the baseline, PointObj.Move is used with the delta displacement.
//   • When run is false or not toggled, the component replays the last output messages/tree.
//   • After processing, schedules GhcGetPointInfo components in the document to refresh.
// -------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using ETABSv1;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using static MGT.ComponentShared;
using Excel = Microsoft.Office.Interop.Excel;

namespace MGT
{
    public class GhcSetPointInfo_ExcelInteraction : GH_Component
    {
        private const string DefaultSheetName = "Point Info";
        private const int ExcelStartColumn = 1; // Column A
        private const int ColumnCount = 6;
        private const double CoordinateTolerance = 1e-6;
        private static readonly int HighlightColor = ColorTranslator.ToOle(Color.LightGray);
        private static readonly int ClearColor = ColorTranslator.ToOle(Color.White);

        private bool _lastRun;
        private GH_Structure<GH_ObjectWrapper> _lastValues = new GH_Structure<GH_ObjectWrapper>();
        private readonly List<string> _lastActions = new List<string>();
        private readonly List<string> _lastMessages = new List<string> { "No previous run. Toggle 'run' to execute." };

        public GhcSetPointInfo_ExcelInteraction()
          : base(
                "Set Point Info (Excel Diff)",
                "SetPointInfoDiff",
                "Rename and move ETABS point objects by reading an Excel worksheet, highlighting edited cells and diffing against a baseline tree.\nDeveloped by Mark Bui Quang Anh - Mark.Bui@meinhardtgroup.com",
                "MGT",
                "2.0 Point Object Modelling")
        {
        }

        public override Guid ComponentGuid => new Guid("2B8B94C9-77E2-4D4B-882D-7477D0A3B6C8");

        protected override Bitmap Icon => null;

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddBooleanParameter("run", "run", "Rising-edge trigger; executes when this turns True.", GH_ParamAccess.item, false);
            p.AddGenericParameter("sapModel", "sapModel", "ETABS cSapModel from the Attach component.", GH_ParamAccess.item);
            p.AddTextParameter("excelPath", "excelPath", "Full or project-relative path to the workbook.", GH_ParamAccess.item, string.Empty);
            p.AddTextParameter("sheetName", "sheetName", "Worksheet name containing the data.", GH_ParamAccess.item, DefaultSheetName);

            int baselineIndex = p.AddGenericParameter(
                "baseline",
                "baseline",
                "Optional data tree captured from GhcGetPointInfo for diff/highlighting.",
                GH_ParamAccess.tree);
            p[baselineIndex].Optional = true;
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddGenericParameter("values", "values", "Column-wise data tree (6 branches) read from Excel (header row excluded).", GH_ParamAccess.tree);
            p.AddTextParameter("actions", "actions", "Rename/move actions executed on ETABS points.", GH_ParamAccess.list);
            p.AddTextParameter("messages", "messages", "Summary and diagnostic messages.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess da)
        {
            bool run = false;
            cSapModel sapModel = null;
            string excelPath = null;
            string sheetName = DefaultSheetName;
            GH_Structure<IGH_Goo> baselineTree;

            da.GetData(0, ref run);
            da.GetData(1, ref sapModel);
            da.GetData(2, ref excelPath);
            da.GetData(3, ref sheetName);
            da.GetDataTree(4, out baselineTree);

            bool rising = !_lastRun && run;
            if (!rising)
            {
                da.SetDataTree(0, _lastValues.Duplicate());
                da.SetDataList(1, _lastActions.ToArray());
                da.SetDataList(2, _lastMessages.ToArray());
                _lastRun = run;
                return;
            }

            List<string> messages = new List<string>();
            List<string> actions = new List<string>();
            GH_Structure<GH_ObjectWrapper> valueTree = new GH_Structure<GH_ObjectWrapper>();

            try
            {
                if (sapModel == null)
                {
                    throw new InvalidOperationException("sapModel is null. Wire it from the Attach component.");
                }

                string fullPath = ExcelHelpers.ProjectRelative(excelPath);
                if (string.IsNullOrWhiteSpace(fullPath))
                {
                    throw new InvalidOperationException("excelPath is empty.");
                }

                if (!File.Exists(fullPath))
                {
                    throw new FileNotFoundException("Excel workbook not found.", fullPath);
                }

                if (string.IsNullOrWhiteSpace(sheetName))
                {
                    sheetName = DefaultSheetName;
                }

                UiHelpers.ShowDualProgressBar(
                    "Set Point Information",
                    "Reading Excel...",
                    0,
                    "Updating points...",
                    0);

                PointBaselineData baselineData = ParseBaselineTree(baselineTree);

                int highlightedCells;
                ExcelPointData excelData = ReadExcelSheet(
                    fullPath,
                    sheetName,
                    baselineData,
                    out highlightedCells,
                    (current, maximum, status) => UiHelpers.UpdateExcelProgressBar(current, maximum, status));

                valueTree = BuildValueTree(excelData);

                EnsureModelUnlocked(sapModel);

                HashSet<string> existingNames = TryGetExistingPointNames(sapModel);
                if (existingNames == null)
                {
                    throw new InvalidOperationException("Failed to query point names from ETABS.");
                }

                int totalRows = excelData.RowCount;
                if (totalRows == 0)
                {
                    messages.Add("Excel sheet contained no point rows.");
                }
                else
                {
                    UiHelpers.UpdateAssignmentProgressBar(0, totalRows, BuildProgressStatus(0, totalRows));

                    int renameCount = 0;
                    int moveCount = 0;
                    int processed = 0;

                    for (int i = 0; i < totalRows; i++)
                    {
                        string desiredName = SafeString(excelData.UniqueNames, i);
                        string baselineName = baselineData.GetString(0, i);
                        string workingName = string.IsNullOrWhiteSpace(baselineName) ? desiredName : baselineName;
                        string rowLabel = $"Row {i + 2}";

                        if (string.IsNullOrWhiteSpace(desiredName))
                        {
                            messages.Add($"{rowLabel}: UniqueName is blank. Skipped.");
                            UiHelpers.UpdateAssignmentProgressBar(++processed, totalRows, BuildProgressStatus(processed, totalRows));
                            continue;
                        }

                        if (string.IsNullOrWhiteSpace(workingName))
                        {
                            workingName = desiredName;
                        }

                        if (!existingNames.Contains(workingName) && existingNames.Contains(desiredName))
                        {
                            workingName = desiredName;
                        }

                        if (!existingNames.Contains(workingName))
                        {
                            messages.Add($"{rowLabel}: Point '{workingName}' not found in ETABS. Skipped.");
                            UiHelpers.UpdateAssignmentProgressBar(++processed, totalRows, BuildProgressStatus(processed, totalRows));
                            continue;
                        }

                        if (!string.IsNullOrWhiteSpace(baselineName) &&
                            !string.Equals(desiredName, baselineName, StringComparison.Ordinal))
                        {
                            int ret = sapModel.PointObj.ChangeName(baselineName, desiredName);
                            if (ret == 0)
                            {
                                renameCount++;
                                actions.Add($"{rowLabel}: Renamed '{baselineName}' -> '{desiredName}'.");
                                existingNames.Remove(baselineName);
                                existingNames.Add(desiredName);
                                workingName = desiredName;
                            }
                            else
                            {
                                messages.Add($"{rowLabel}: ChangeName failed ({ret}) for '{baselineName}' -> '{desiredName}'.");
                                workingName = baselineName;
                            }
                        }

                        double? baselineX = baselineData.GetDouble(3, i);
                        double? baselineY = baselineData.GetDouble(4, i);
                        double? baselineZ = baselineData.GetDouble(5, i);

                        if (!baselineX.HasValue || !baselineY.HasValue || !baselineZ.HasValue)
                        {
                            if (TryGetPointCoordinates(sapModel, workingName, out double currentX, out double currentY, out double currentZ))
                            {
                                baselineX = currentX;
                                baselineY = currentY;
                                baselineZ = currentZ;
                            }
                        }

                        double? newX = excelData.GetCoordinate(excelData.X, i);
                        double? newY = excelData.GetCoordinate(excelData.Y, i);
                        double? newZ = excelData.GetCoordinate(excelData.Z, i);

                        if (baselineX.HasValue && baselineY.HasValue && baselineZ.HasValue)
                        {
                            double targetX = newX ?? baselineX.Value;
                            double targetY = newY ?? baselineY.Value;
                            double targetZ = newZ ?? baselineZ.Value;

                            double dx = targetX - baselineX.Value;
                            double dy = targetY - baselineY.Value;
                            double dz = targetZ - baselineZ.Value;

                            if (HasSignificantDelta(dx, dy, dz))
                            {
                                int retMove = sapModel.PointObj.Move(workingName, dx, dy, dz);
                                if (retMove == 0)
                                {
                                    moveCount++;
                                    actions.Add($"{rowLabel}: Moved '{workingName}' by ({dx:0.###}, {dy:0.###}, {dz:0.###}).");
                                }
                                else
                                {
                                    messages.Add($"{rowLabel}: Move failed ({retMove}) for '{workingName}'.");
                                }
                            }
                        }

                        UiHelpers.UpdateAssignmentProgressBar(++processed, totalRows, BuildProgressStatus(processed, totalRows));
                    }

                    messages.Add($"Processed {totalRows} row(s).");
                    if (renameCount > 0)
                    {
                        messages.Add($"Renamed {renameCount} point(s).");
                    }
                    if (moveCount > 0)
                    {
                        messages.Add($"Moved {moveCount} point(s).");
                    }
                }

                if (highlightedCells > 0)
                {
                    messages.Add($"Highlighted {highlightedCells} changed cell(s) in Excel.");
                }

                try
                {
                    sapModel.View.RefreshView(0, false);
                }
                catch
                {
                    // ignored
                }

                int refreshCount = TriggerGetPointInfoRefresh();
                if (refreshCount > 0)
                {
                    messages.Add($"Scheduled refresh for {Plural(refreshCount, "Get Point Info component")}." );
                }
            }
            catch (Exception ex)
            {
                messages.Clear();
                messages.Add("Error: " + ex.Message);
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
            }
            finally
            {
                UiHelpers.CloseProgressBar();

                da.SetDataTree(0, valueTree);
                da.SetDataList(1, actions);
                da.SetDataList(2, messages);

                _lastValues = valueTree.Duplicate();
                _lastActions.Clear();
                _lastActions.AddRange(actions);
                _lastMessages.Clear();
                _lastMessages.AddRange(messages);
                _lastRun = run;
            }
        }

        private static string SafeString(List<string> values, int index)
        {
            if (values == null || index < 0 || index >= values.Count)
            {
                return string.Empty;
            }

            string value = values[index];
            return string.IsNullOrWhiteSpace(value) ? string.Empty : value.Trim();
        }

        private static bool HasSignificantDelta(double dx, double dy, double dz)
        {
            return Math.Abs(dx) > CoordinateTolerance ||
                   Math.Abs(dy) > CoordinateTolerance ||
                   Math.Abs(dz) > CoordinateTolerance;
        }

        private static bool TryGetPointCoordinates(cSapModel model, string pointName, out double x, out double y, out double z)
        {
            x = 0.0;
            y = 0.0;
            z = 0.0;

            if (model == null || string.IsNullOrWhiteSpace(pointName))
            {
                return false;
            }

            double xi = 0.0;
            double yi = 0.0;
            double zi = 0.0;

            int ret = model.PointObj.GetCoordCartesian(pointName, ref xi, ref yi, ref zi);
            if (ret != 0)
            {
                return false;
            }

            x = xi;
            y = yi;
            z = zi;
            return true;
        }

        private static PointBaselineData ParseBaselineTree(GH_Structure<IGH_Goo> tree)
        {
            PointBaselineData data = new PointBaselineData();
            if (tree == null)
            {
                return data;
            }

            data.UniqueNames = ExtractStringBranch(tree, 0);
            data.Labels = ExtractStringBranch(tree, 1);
            data.Stories = ExtractStringBranch(tree, 2);
            data.X = ExtractDoubleBranch(tree, 3);
            data.Y = ExtractDoubleBranch(tree, 4);
            data.Z = ExtractDoubleBranch(tree, 5);
            return data;
        }

        private static List<string> ExtractStringBranch(GH_Structure<IGH_Goo> tree, int index)
        {
            List<string> result = new List<string>();
            if (tree == null || index < 0 || index >= tree.PathCount)
            {
                return result;
            }

            IList<IGH_Goo> branch = tree.get_Branch(index);
            if (branch == null)
            {
                return result;
            }

            for (int i = 0; i < branch.Count; i++)
            {
                IGH_Goo goo = branch[i];
                if (goo == null)
                {
                    result.Add(string.Empty);
                    continue;
                }

                string text;
                if (GH_Convert.ToString(goo, out text, GH_Conversion.Both))
                {
                    result.Add(string.IsNullOrWhiteSpace(text) ? string.Empty : text.Trim());
                }
                else
                {
                    result.Add(string.Empty);
                }
            }

            return result;
        }

        private static List<double?> ExtractDoubleBranch(GH_Structure<IGH_Goo> tree, int index)
        {
            List<double?> result = new List<double?>();
            if (tree == null || index < 0 || index >= tree.PathCount)
            {
                return result;
            }

            IList<IGH_Goo> branch = tree.get_Branch(index);
            if (branch == null)
            {
                return result;
            }

            for (int i = 0; i < branch.Count; i++)
            {
                IGH_Goo goo = branch[i];
                if (goo == null)
                {
                    result.Add(null);
                    continue;
                }

                double value;
                if (GH_Convert.ToDouble(goo, out value, GH_Conversion.Both))
                {
                    result.Add(value);
                }
                else
                {
                    result.Add(null);
                }
            }

            return result;
        }

        private static ExcelPointData ReadExcelSheet(
            string fullPath,
            string sheetName,
            PointBaselineData baseline,
            out int highlightedCells,
            Action<int, int, string> progressCallback)
        {
            Excel.Application app = null;
            Excel.Workbooks books = null;
            Excel.Workbook wb = null;
            Excel.Worksheet ws = null;
            Excel.Range usedRange = null;

            highlightedCells = 0;
            bool workbookModified = false;

            try
            {
                app = new Excel.Application
                {
                    Visible = false,
                    DisplayAlerts = false,
                    UserControl = false
                };

                books = app.Workbooks;
                wb = books.Open(
                    Filename: fullPath,
                    UpdateLinks: 0,
                    ReadOnly: false,
                    IgnoreReadOnlyRecommended: true,
                    AddToMru: false);

                ws = FindWorksheet(wb, sheetName);
                if (ws == null)
                {
                    throw new InvalidOperationException($"Worksheet '{sheetName}' not found in '{Path.GetFileName(fullPath)}'.");
                }

                ExcelPointData data = new ExcelPointData();

                string[] expectedHeaders =
                {
                    "UniqueName",
                    "Label",
                    "Story",
                    "X",
                    "Y",
                    "Z"
                };

                for (int col = 0; col < ColumnCount; col++)
                {
                    Excel.Range headerCell = null;
                    try
                    {
                        headerCell = (Excel.Range)ws.Cells[1, ExcelStartColumn + col];
                        string headerValue = TrimOrEmpty(headerCell?.Value2);
                        data.Headers.Add(headerValue);

                        if (!string.Equals(headerValue, expectedHeaders[col], StringComparison.OrdinalIgnoreCase))
                        {
                            char columnLetter = (char)('A' + ExcelStartColumn + col - 1);
                            throw new InvalidOperationException(
                                $"Invalid workbook: expected header '{expectedHeaders[col]}' in column {columnLetter}, found '{headerValue}'.");
                        }
                    }
                    finally
                    {
                        ExcelHelpers.ReleaseCom(headerCell);
                    }
                }

                usedRange = ws.UsedRange;
                int lastRow = 1;
                if (usedRange != null)
                {
                    try
                    {
                        lastRow = Math.Max(lastRow, usedRange.Row + usedRange.Rows.Count - 1);
                    }
                    catch
                    {
                        lastRow = 1;
                    }
                }

                int totalRows = Math.Max(0, lastRow - 1);
                progressCallback?.Invoke(0, totalRows, BuildExcelProgressStatus(0, totalRows));

                int processedRows = 0;

                for (int row = 2; row <= lastRow; row++)
                {
                    object[] rowValues = new object[ColumnCount];
                    bool hasData = false;

                    for (int col = 0; col < ColumnCount; col++)
                    {
                        Excel.Range cell = null;
                        try
                        {
                            cell = (Excel.Range)ws.Cells[row, ExcelStartColumn + col];
                            object value = cell?.Value2;
                            rowValues[col] = value;
                            if (!IsNullOrEmptyExcel(value))
                            {
                                hasData = true;
                            }

                            int branchIndex = col;
                            int valueIndex = row - 2;
                            bool changed = IsCellChanged(baseline, branchIndex, valueIndex, value);
                            if (ApplyHighlight(cell, changed))
                            {
                                workbookModified = true;
                            }
                            if (changed)
                            {
                                highlightedCells++;
                            }
                        }
                        finally
                        {
                            ExcelHelpers.ReleaseCom(cell);
                        }
                    }

                    processedRows++;
                    int current = totalRows > 0 ? Math.Min(processedRows, totalRows) : processedRows;
                    progressCallback?.Invoke(current, totalRows, BuildExcelProgressStatus(current, totalRows));

                    if (!hasData)
                    {
                        continue;
                    }

                    data.UniqueNames.Add(TrimOrEmpty(rowValues[0]));
                    data.Labels.Add(TrimOrEmpty(rowValues[1]));
                    data.Stories.Add(TrimOrEmpty(rowValues[2]));
                    data.X.Add(ParseNullableDouble(rowValues[3]));
                    data.Y.Add(ParseNullableDouble(rowValues[4]));
                    data.Z.Add(ParseNullableDouble(rowValues[5]));
                }

                progressCallback?.Invoke(data.RowCount, data.RowCount, BuildExcelDoneStatus(data.RowCount));

                if (workbookModified)
                {
                    try
                    {
                        wb.Save();
                    }
                    catch
                    {
                        // ignored
                    }
                }

                return data;
            }
            finally
            {
                ExcelHelpers.ReleaseCom(usedRange);

                if (wb != null)
                {
                    try { wb.Close(false); } catch { }
                }

                ExcelHelpers.ReleaseCom(ws);
                ExcelHelpers.ReleaseCom(wb);
                ExcelHelpers.ReleaseCom(books);

                if (app != null)
                {
                    try { app.Quit(); } catch { }
                }

                ExcelHelpers.ReleaseCom(app);
            }
        }

        private static Excel.Worksheet FindWorksheet(Excel.Workbook wb, string sheetName)
        {
            if (wb == null)
            {
                return null;
            }

            if (string.IsNullOrWhiteSpace(sheetName))
            {
                sheetName = DefaultSheetName;
            }

            Excel.Worksheet result = null;

            for (int i = 1; i <= wb.Worksheets.Count; i++)
            {
                Excel.Worksheet candidate = null;
                try
                {
                    candidate = (Excel.Worksheet)wb.Worksheets[i];
                    if (candidate != null && string.Equals(candidate.Name, sheetName, StringComparison.OrdinalIgnoreCase))
                    {
                        result = candidate;
                        candidate = null;
                        break;
                    }
                }
                finally
                {
                    ExcelHelpers.ReleaseCom(candidate);
                }
            }

            return result;
        }

        private static bool ApplyHighlight(Excel.Range cell, bool changed)
        {
            if (cell == null)
            {
                return false;
            }

            Excel.Interior interior = null;
            try
            {
                interior = cell.Interior;
                if (interior == null)
                {
                    return false;
                }

                int currentColor = 0;
                bool hasColor = false;
                object colorObj = null;
                try
                {
                    colorObj = interior.Color;
                    if (colorObj is double colorDouble)
                    {
                        currentColor = Convert.ToInt32(colorDouble);
                        hasColor = true;
                    }
                    else if (colorObj is int colorInt)
                    {
                        currentColor = colorInt;
                        hasColor = true;
                    }
                }
                catch
                {
                    hasColor = false;
                }

                bool currentlyGrey = hasColor && currentColor == HighlightColor;

                if (changed)
                {
                    if (!currentlyGrey)
                    {
                        interior.Pattern = Excel.XlPattern.xlPatternSolid;
                        interior.PatternColorIndex = Excel.XlColorIndex.xlColorIndexAutomatic;
                        interior.Color = HighlightColor;
                        return true;
                    }

                    return false;
                }

                if (currentlyGrey)
                {
                    interior.Pattern = Excel.XlPattern.xlPatternSolid;
                    interior.PatternColorIndex = Excel.XlColorIndex.xlColorIndexAutomatic;
                    interior.Color = ClearColor;
                    return true;
                }

                return false;
            }
            finally
            {
                if (interior != null)
                {
                    ExcelHelpers.ReleaseCom(interior);
                }
            }
        }

        private static bool IsCellChanged(PointBaselineData baseline, int columnIndex, int rowIndex, object excelValue)
        {
            if (baseline == null)
            {
                return !IsNullOrEmptyExcel(excelValue);
            }

            if (columnIndex < 0 || rowIndex < 0)
            {
                return false;
            }

            if (columnIndex <= 2)
            {
                string baselineValue = baseline.GetString(columnIndex, rowIndex) ?? string.Empty;
                string excelText = TrimOrEmpty(excelValue);
                return !string.Equals(baselineValue, excelText, StringComparison.Ordinal);
            }

            double? baselineDouble = baseline.GetDouble(columnIndex, rowIndex);
            double? excelDouble = ParseNullableDouble(excelValue);

            if (baselineDouble.HasValue && excelDouble.HasValue)
            {
                return Math.Abs(baselineDouble.Value - excelDouble.Value) > CoordinateTolerance;
            }

            return baselineDouble.HasValue != excelDouble.HasValue;
        }

        private static bool IsNullOrEmptyExcel(object value)
        {
            if (value == null)
            {
                return true;
            }

            if (value is string s)
            {
                return string.IsNullOrWhiteSpace(s);
            }

            return false;
        }

        private static string TrimOrEmpty(object value)
        {
            if (value == null)
            {
                return string.Empty;
            }

            string s = Convert.ToString(value, CultureInfo.InvariantCulture);
            return string.IsNullOrWhiteSpace(s) ? string.Empty : s.Trim();
        }

        private static double? ParseNullableDouble(object value)
        {
            if (value == null)
            {
                return null;
            }

            if (value is double d)
            {
                return d;
            }

            string s = TrimOrEmpty(value);
            if (string.IsNullOrEmpty(s))
            {
                return null;
            }

            if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out double parsed))
            {
                return parsed;
            }

            return null;
        }

        private static string BuildProgressStatus(int processed, int total)
        {
            if (total <= 0)
            {
                return string.Empty;
            }

            double percent = total == 0 ? 0.0 : (processed / (double)total) * 100.0;
            return $"Processed {processed} of {total} point(s) ({percent:0.##}%).";
        }

        private static string BuildExcelProgressStatus(int processedRows, int totalRows)
        {
            int safeProcessed = Math.Max(0, processedRows);
            int safeTotal = Math.Max(0, totalRows);
            if (safeTotal <= 0)
            {
                return $"Reading Excel ({safeProcessed})";
            }

            int clamped = Math.Min(safeProcessed, safeTotal);
            double percent = (clamped / (double)safeTotal) * 100.0;
            return $"Reading Excel {clamped} of {safeTotal} rows ({percent:0.##}%).";
        }

        private static string BuildExcelDoneStatus(int rowCount)
        {
            int safeCount = Math.Max(0, rowCount);
            return safeCount == 1
                ? "Excel Done (1 row)"
                : $"Excel Done ({safeCount} rows)";
        }

        private static GH_Structure<GH_ObjectWrapper> BuildValueTree(ExcelPointData data)
        {
            GH_Structure<GH_ObjectWrapper> tree = new GH_Structure<GH_ObjectWrapper>();

            AppendBranch(tree, 0, data.UniqueNames);
            AppendBranch(tree, 1, data.Labels);
            AppendBranch(tree, 2, data.Stories);
            AppendBranch(tree, 3, data.X);
            AppendBranch(tree, 4, data.Y);
            AppendBranch(tree, 5, data.Z);

            return tree;
        }

        private static void AppendBranch<T>(GH_Structure<GH_ObjectWrapper> tree, int index, IList<T> values)
        {
            GH_Path path = new GH_Path(index);
            tree.EnsurePath(path);

            if (values == null)
            {
                return;
            }

            for (int i = 0; i < values.Count; i++)
            {
                tree.Append(new GH_ObjectWrapper(values[i]), path);
            }
        }

        private static HashSet<string> TryGetExistingPointNames(cSapModel model)
        {
            if (model == null)
            {
                return null;
            }

            try
            {
                int count = 0;
                string[] names = null;
                int ret = model.PointObj.GetNameList(ref count, ref names);
                if (ret != 0)
                {
                    return null;
                }

                HashSet<string> result = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (names == null)
                {
                    return result;
                }

                for (int i = 0; i < names.Length; i++)
                {
                    string nm = names[i];
                    if (!string.IsNullOrWhiteSpace(nm))
                    {
                        result.Add(nm.Trim());
                    }
                }

                return result;
            }
            catch
            {
                return null;
            }
        }

        private int TriggerGetPointInfoRefresh()
        {
            try
            {
                GH_Document document = OnPingDocument();
                if (document == null)
                {
                    return 0;
                }

                List<GhcGetPointInfo> targets = new List<GhcGetPointInfo>();
                foreach (IGH_DocumentObject obj in document.Objects)
                {
                    if (obj is GhcGetPointInfo getComponent &&
                        ReferenceEquals(getComponent.OnPingDocument(), document) &&
                        !getComponent.Locked &&
                        !getComponent.Hidden)
                    {
                        targets.Add(getComponent);
                    }
                }

                if (targets.Count == 0)
                {
                    return 0;
                }

                document.ScheduleSolution(5, _ =>
                {
                    foreach (GhcGetPointInfo target in targets)
                    {
                        if (!target.Locked && !target.Hidden)
                        {
                            target.ExpireSolution(false);
                        }
                    }
                });

                return targets.Count;
            }
            catch
            {
                return 0;
            }
        }

        private class ExcelPointData
        {
            internal List<string> Headers { get; } = new List<string>();
            internal List<string> UniqueNames { get; } = new List<string>();
            internal List<string> Labels { get; } = new List<string>();
            internal List<string> Stories { get; } = new List<string>();
            internal List<double?> X { get; } = new List<double?>();
            internal List<double?> Y { get; } = new List<double?>();
            internal List<double?> Z { get; } = new List<double?>();

            internal int RowCount => UniqueNames.Count;

            internal double? GetCoordinate(List<double?> source, int index)
            {
                if (source == null || index < 0 || index >= source.Count)
                {
                    return null;
                }

                return source[index];
            }
        }

        private class PointBaselineData
        {
            internal List<string> UniqueNames { get; set; } = new List<string>();
            internal List<string> Labels { get; set; } = new List<string>();
            internal List<string> Stories { get; set; } = new List<string>();
            internal List<double?> X { get; set; } = new List<double?>();
            internal List<double?> Y { get; set; } = new List<double?>();
            internal List<double?> Z { get; set; } = new List<double?>();

            internal string GetString(int columnIndex, int rowIndex)
            {
                List<string> target = columnIndex switch
                {
                    0 => UniqueNames,
                    1 => Labels,
                    2 => Stories,
                    _ => null
                };

                if (target == null || rowIndex < 0 || rowIndex >= target.Count)
                {
                    return string.Empty;
                }

                string value = target[rowIndex];
                return string.IsNullOrWhiteSpace(value) ? string.Empty : value.Trim();
            }

            internal double? GetDouble(int columnIndex, int rowIndex)
            {
                List<double?> target = columnIndex switch
                {
                    3 => X,
                    4 => Y,
                    5 => Z,
                    _ => null
                };

                if (target == null || rowIndex < 0 || rowIndex >= target.Count)
                {
                    return null;
                }

                return target[rowIndex];
            }
        }
    }
}

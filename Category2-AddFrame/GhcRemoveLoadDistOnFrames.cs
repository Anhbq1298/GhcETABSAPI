// -------------------------------------------------------------
// Component : Remove Frame Distributed Loads
// Author    : Generated by ChatGPT
// Target    : Rhino 7/8 + Grasshopper, .NET Framework 4.8 (x64)
// Depends   : Grasshopper, ETABSv1 (COM)  [Embed Interop Types = False]
// Panel     : "MGT" / "2.0 Frame Object Modelling"
// -------------------------------------------------------------
// Inputs (ordered):
//   0) run         (bool, item)    Rising-edge trigger.
//   1) sapModel    (ETABSv1.cSapModel, item)  ETABS model from Attach component.
//   2) frameNames  (string, list)  Frame object names to process. Blank/dup ignored (case-insensitive).
//   3) loadPatterns(string, list)  OPTIONAL filters. Empty ⇒ remove all distributed loads on each frame.
//
// Outputs:
//   0) messages    (string, list)  Summary + diagnostics.
//
// Behavior Notes:
//   • Queries existing distributed loads via FrameObj.GetLoadDistributed (per object).
//   • When loadPatterns is empty/omitted, all distributed load assignments are removed.
//   • When loadPatterns are provided, only matching load pattern assignments are removed (case-insensitive).
//   • Attempts relative-distance deletion first, then falls back to absolute distances if needed.
//   • Attempts to unlock the model before editing. Frames not found are reported.
//   • When run is false or not toggled, the component replays the last output messages.
// -------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Drawing;
using ETABSv1;
using Grasshopper.Kernel;
using static MGT.ComponentShared;

namespace MGT
{
    public class GhcRemoveLoadDistOnFrames : GH_Component
    {
        private bool _lastRun;
        private readonly List<string> _lastMessages = new List<string> { "No previous run. Toggle 'run' to remove loads." };

        public GhcRemoveLoadDistOnFrames()
          : base(
                "Remove Frame Distributed Loads",
                "RemoveFrameUDL",
                "Remove distributed load assignments from ETABS frame objects (per object mode).\nDeveloped by Mark Bui Quang Anh - Mark.Bui@meinhardtgroup.com",
                "MGT",
                "2.0 Frame Object Modelling")
        {
        }

        public override Guid ComponentGuid => new Guid("f5f77319-2b0a-4f0a-898b-7a0c4527f991");

        protected override Bitmap Icon => null;

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddBooleanParameter("run", "run", "Rising-edge trigger; executes when this turns True.", GH_ParamAccess.item, false);
            p.AddGenericParameter("sapModel", "sapModel", "ETABS cSapModel from the Attach component.", GH_ParamAccess.item);
            int frameIndex = p.AddTextParameter(
                "frameNames",
                "frameNames",
                "Frame object names to process. Blank entries are ignored. Duplicate names are removed (case-insensitive).",
                GH_ParamAccess.list);
            p[frameIndex].Optional = true;

            int patternIndex = p.AddTextParameter(
                "loadPatterns",
                "loadPatterns",
                "Optional load pattern filters. Leave empty to remove all distributed loads from the frames.",
                GH_ParamAccess.list);
            p[patternIndex].Optional = true;
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddTextParameter("messages", "messages", "Summary and diagnostic messages.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess da)
        {
            bool run = false;
            cSapModel sapModel = null;
            List<string> frameNames = new List<string>();
            List<string> loadPatterns = new List<string>();

            da.GetData(0, ref run);
            da.GetData(1, ref sapModel);
            da.GetDataList(2, frameNames);
            da.GetDataList(3, loadPatterns);

            bool rising = !_lastRun && run;
            if (!rising)
            {
                da.SetDataList(0, _lastMessages);
                _lastRun = run;
                return;
            }

            List<string> messages = new List<string>();
            int scheduledRefreshCount = 0;

            try
            {
                if (sapModel == null)
                {
                    throw new InvalidOperationException("sapModel is null. Wire it from the Attach component.");
                }

                List<string> cleanedFrames = NormalizeDistinct(frameNames);
                if (cleanedFrames.Count == 0)
                {
                    messages.Add("No valid frame names provided.");
                    PushOutputs(da, messages, run);
                    return;
                }

                List<string> cleanedPatterns = NormalizeDistinct(loadPatterns);
                HashSet<string> patternSet = null;
                if (cleanedPatterns.Count > 0)
                {
                    patternSet = new HashSet<string>(cleanedPatterns, StringComparer.OrdinalIgnoreCase);
                }

                EnsureModelUnlocked(sapModel);
                HashSet<string> existingNames = TryGetExistingFrameNames(sapModel);

                int framesMissing = 0;
                int queryFailures = 0;
                int targetedLoads = 0;
                int removedLoads = 0;
                int failedRemovals = 0;
                HashSet<string> framesModified = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                List<string> missingNames = new List<string>();
                List<string> queryFailedNames = new List<string>();
                List<string> failedAssignments = new List<string>();

                foreach (string rawName in cleanedFrames)
                {
                    if (string.IsNullOrWhiteSpace(rawName))
                    {
                        continue;
                    }

                    string frameName = rawName.Trim();
                    if (frameName.Length == 0)
                    {
                        continue;
                    }

                    if (existingNames != null && !existingNames.Contains(frameName))
                    {
                        framesMissing++;
                        missingNames.Add(frameName);
                        continue;
                    }

                    var loadResult = CollectDistributedLoads(sapModel, frameName);
                    if (!loadResult.success)
                    {
                        queryFailures++;
                        queryFailedNames.Add(frameName);
                        continue;
                    }

                    if (loadResult.entries.Count == 0)
                    {
                        continue;
                    }

                    bool anyTargetOnFrame = false;

                    HashSet<string> processedPatterns = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                    foreach (DistributedLoadEntry entry in loadResult.entries)
                    {
                        string entryPattern = entry.LoadPattern ?? string.Empty;
                        bool matches = patternSet == null || patternSet.Contains(entryPattern);
                        if (!matches)
                        {
                            continue;
                        }

                        if (!processedPatterns.Add(entryPattern))
                        {
                            continue;
                        }

                        anyTargetOnFrame = true;
                        targetedLoads++;

                        if (TryDeleteLoad(sapModel, frameName, entryPattern))
                        {
                            removedLoads++;
                            framesModified.Add(frameName);
                        }
                        else
                        {
                            failedRemovals++;
                            failedAssignments.Add($"{frameName}:{entry.LoadPattern}");
                        }
                    }

                }

                if (removedLoads > 0)
                {
                    messages.Add($"Removed {Plural(removedLoads, "distributed load assignment")} from {Plural(framesModified.Count, "frame")}.");
                }
                else if (targetedLoads > 0)
                {
                    messages.Add($"Attempted to remove {Plural(targetedLoads, "distributed load assignment")}, but none succeeded.");
                }
                else
                {
                    if (patternSet == null)
                    {
                        messages.Add("No distributed loads found on the specified frames.");
                    }
                    else
                    {
                        string summary = FormatLoadPatternSummary(cleanedPatterns);
                        messages.Add($"No distributed loads matched {summary} on the specified frames.");
                    }
                }

                if (failedRemovals > 0)
                {
                    messages.Add("Failed removals (frame:pattern): " + string.Join(", ", failedAssignments));
                }

                if (framesMissing > 0)
                {
                    messages.Add("Missing frames: " + string.Join(", ", missingNames));
                }

                if (queryFailures > 0)
                {
                    messages.Add("Load query failed for frames: " + string.Join(", ", queryFailedNames));
                }

                if (removedLoads > 0)
                {
                    try
                    {
                        sapModel.View.RefreshView(0, false);
                    }
                    catch
                    {
                        // ignored
                    }

                    scheduledRefreshCount = TriggerGetComponentRefresh();
                }
            }
            catch (Exception ex)
            {
                messages.Add("Error: " + ex.Message);
            }

            if (scheduledRefreshCount > 0)
            {
                messages.Add($"Scheduled refresh for {Plural(scheduledRefreshCount, \"Get Frame Distributed Loads component\")}.");
            }

            PushOutputs(da, messages, run);
        }

        private int TriggerGetComponentRefresh()
        {
            try
            {
                GH_Document document = OnPingDocument();
                if (document == null)
                {
                    return 0;
                }

                List<GhcGetLoadDistOnFrames> targets = new List<GhcGetLoadDistOnFrames>();
                foreach (IGH_DocumentObject obj in document.Objects)
                {
                    if (obj is GhcGetLoadDistOnFrames getComponent &&
                        ReferenceEquals(getComponent.OnPingDocument(), document) &&
                        !getComponent.Locked &&
                        !getComponent.Hidden)
                    {
                        targets.Add(getComponent);
                    }
                }

                if (targets.Count == 0)
                {
                    return 0;
                }

                document.ScheduleSolution(5, _ =>
                {
                    foreach (GhcGetLoadDistOnFrames target in targets)
                    {
                        if (!target.Locked && !target.Hidden)
                        {
                            target.ExpireSolution(false);
                        }
                    }
                });

                return targets.Count;
            }
            catch
            {
                return 0;
            }
        }

        private void PushOutputs(IGH_DataAccess da, List<string> messages, bool currentRunState)
        {
            da.SetDataList(0, messages);

            _lastMessages.Clear();
            _lastMessages.AddRange(messages);
            _lastRun = currentRunState;
        }

        private static (bool success, List<DistributedLoadEntry> entries) CollectDistributedLoads(cSapModel model, string frameName)
        {
            List<DistributedLoadEntry> entries = new List<DistributedLoadEntry>();
            if (model == null || string.IsNullOrWhiteSpace(frameName))
            {
                return (false, entries);
            }

            try
            {
                int count = 0;
                string[] frameNames = null;
                string[] loadPatterns = null;
                int[] myTypes = null;
                string[] coordinateSystems = null;
                int[] directions = null;
                double[] relDist1 = null;
                double[] relDist2 = null;
                double[] dist1 = null;
                double[] dist2 = null;
                double[] value1 = null;
                double[] value2 = null;

                int ret = model.FrameObj.GetLoadDistributed(
                    frameName,
                    ref count,
                    ref frameNames,
                    ref loadPatterns,
                    ref myTypes,
                    ref coordinateSystems,
                    ref directions,
                    ref relDist1,
                    ref relDist2,
                    ref dist1,
                    ref dist2,
                    ref value1,
                    ref value2,
                    eItemType.Objects);

                if (ret != 0)
                {
                    return (false, entries);
                }

                if (count <= 0 || loadPatterns == null)
                {
                    return (true, entries);
                }

                for (int i = 0; i < count; i++)
                {
                    string pattern = SafeArrayValue(loadPatterns, i);
                    if (!string.IsNullOrWhiteSpace(pattern))
                    {
                        pattern = pattern.Trim();
                    }

                    string csys = SafeArrayValue(coordinateSystems, i);
                    if (!string.IsNullOrWhiteSpace(csys))
                    {
                        csys = csys.Trim();
                    }

                    DistributedLoadEntry entry = new DistributedLoadEntry
                    {
                        FrameName = frameName,
                        LoadPattern = pattern,
                        LoadType = SafeArrayValue(myTypes, i),
                        CoordinateSystem = csys,
                        Direction = SafeArrayValue(directions, i),
                        RelDist1 = SafeArrayValue(relDist1, i),
                        RelDist2 = SafeArrayValue(relDist2, i),
                        Dist1 = SafeArrayValue(dist1, i),
                        Dist2 = SafeArrayValue(dist2, i)
                    };

                    entries.Add(entry);
                }

                return (true, entries);
            }
            catch
            {
                return (false, entries);
            }
        }

        private static bool TryDeleteLoad(cSapModel model, string frameName, string loadPattern)
        {
            if (model == null)
            {
                return false;
            }

            try
            {
                int ret = model.FrameObj.DeleteLoadDistributed(
                    frameName ?? string.Empty,
                    loadPattern ?? string.Empty,
                    eItemType.Objects);

                return ret == 0;
            }
            catch
            {
                return false;
            }
        }

        private static string SafeArrayValue(string[] source, int index)
        {
            if (source == null || index < 0 || index >= source.Length)
            {
                return string.Empty;
            }

            return source[index] ?? string.Empty;
        }

        private static int SafeArrayValue(int[] source, int index)
        {
            if (source == null || index < 0 || index >= source.Length)
            {
                return 0;
            }

            return source[index];
        }

        private static double SafeArrayValue(double[] source, int index)
        {
            if (source == null || index < 0 || index >= source.Length)
            {
                return 0.0;
            }

            double value = source[index];
            if (double.IsNaN(value) || double.IsInfinity(value))
            {
                return 0.0;
            }

            return value;
        }

        private class DistributedLoadEntry
        {
            public string FrameName { get; set; }
            public string LoadPattern { get; set; }
            public int LoadType { get; set; }
            public string CoordinateSystem { get; set; }
            public int Direction { get; set; }
            public double RelDist1 { get; set; }
            public double RelDist2 { get; set; }
            public double Dist1 { get; set; }
            public double Dist2 { get; set; }
        }
    }
}
